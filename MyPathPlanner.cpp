#include "MyPathPlanner.h"
#include "MyGame.h"
#include <iostream> 
#include <queue> 

using namespace mathtool;

namespace GMUCS425
{

MyPathPlanner::MyPathPlanner(MyScene * scene, MyAgent * agent)
{
  m_scene=scene;
  m_agent=agent;
}

//
//TODO: (10 pts)
//about 15~20 lines of code
//
//return true if m_agent collide with a non-movable object
//at a given location
//
bool MyPathPlanner::collision_detection(const Point2d& pos)
{
  //brute force collision detection

  //Hint:
  //methods to use: collide(), getX(), getY(), tranlateTo() in MyAgent
  //get_agents() in MyScene
	//remember original position
	float x0 = m_agent->getX();
	float y0 = m_agent->getY();
	//move to pos
	m_agent->tranlateTo(pos[0], pos[1]);
	//check every agent
	const std::list<MyAgent * > & listOfAgents = m_scene->get_agents();
	for (std::list<MyAgent *>::const_iterator ma = listOfAgents.begin(); ma != listOfAgents.end(); ma++){
	//for (const MyAgent & ma : listOfAgents) {
		if (! (*ma)->is_movable()) {//only static objects
			//if (m_agent->collide(&ma)) {
			if ((*ma)->collide(m_agent)) {
				m_agent->tranlateTo(x0, y0);
				return true;
			}
		}
	}


	m_agent->tranlateTo(x0, y0);
  return false;
}

//TODO: (10 pts)
//estimate the cost of traveling from pos1 to pos2
//distance between pos1 and pos2 scaled using the values generated by Perlin noise
float MyPathPlanner::cost(const Point2d& pos1, const Point2d& pos2)
{
  const Uint32 * terrain = m_scene->get_terrain();
  int terrain_width = getMyGame()->getScreenWidth();
  int terrain_height = getMyGame()->getScreenHeight();

  //terrain is a (terrain_width X terrain_height) array

  float scale=1; //Note: the scale must be larger than 1
  
  //TODO:
  //estimate the scale here, if the terrain value is 0, the scale should be 1
  //if the terrain value is high, the scale should be larger, therefore the cost
  //of going from pos1 to pos2 is higher

  //Hint: there are many correct implementations, use your imagination
  float scales = 0;
  int x0 = pos1[0];

  float dx = pos2[0] - pos1[0];
  float dy = pos2[1] - pos1[1];
  float dist = sqrt(dx * dx + dy * dy);
  float c = 0;
  int iters = 10;
  if (dist < 1) {
	  for (int i = 0; i < iters; i++) {
		  int x = pos1[0] + dx * i / iters;
		  int y = pos1[1] + dx * i / iters;

		  Uint32 watery = terrain[((int)y)*terrain_width + ((int)x)] & 255;
		  float scale = (2 - watery * 1.0f / 255); //1~2
		  scales += scale; //(terrain[(int)(pos1[0] + (i / dist)*dx) + (int)(pos1[1] + (i / dist)*dy)*terrain_width]) / 10;
		  //c += scale / 10;
	  }
	  return scales/iters * (pos1 - pos2).norm(); //scale this by the value in terrain
  }
  else {
	  return 1 * (pos1 - pos2).norm(); //scale this by the value in terrain
  }
  //return c;
  return scale * (pos1-pos2).norm(); //scale this by the value in terrain
}

//------------
//TODO: (20 pts)
bool MyGridPathPlanner::build() //build a grid
{
  if(!m_grid.empty()) return false; //build only if the grid is empty

  m_grid=std::vector< std::vector<Node> >( m_height, std::vector<Node>(m_width,Node()) );
  float cell_w=getMyGame()->getScreenWidth()*1.0f/m_width;
  float cell_h=getMyGame()->getScreenHeight()*1.0f/m_height;

  //TODO: go through the nodes (cells) in the grid, and initial the data for each node
  for(int i=0;i<m_height;i++)
  {
    for(int j=0;j<m_width;j++)
    {
      Node & n=m_grid[i][j];

      //determine the values of n.pos, n.free and n.neighbors
	  //pos
	  n.pos = Point2d(j*cell_w, i*cell_h);
	  //free
	  n.free = !collision_detection(n.pos);
	  
	  if (n.free) {
		  
		  if ((i > 0) /*&& !collision_detection(Point2d((n.pos[0] ), (n.pos[0] - cell_h / 2)))*/) {// top edge
			  n.neighbors.push_front(&m_grid[i - 1][j]);
		  }
		  if ((j > 0) /*&& !collision_detection(Point2d((n.pos[0] - cell_w / 2), (n.pos[0] )))*/) {//left edge
			  n.neighbors.push_front(&m_grid[i][j - 1]);
		  }
		  if ((j < m_width-1) /*&& !collision_detection(Point2d((n.pos[0] + cell_w / 2), (n.pos[0])))*/) {//right edge
			  n.neighbors.push_front(&m_grid[i][j + 1]);
		  }
		  if ((i < m_height-1) /*&& !collision_detection(Point2d((n.pos[0]), (n.pos[0] - cell_h / 2)))*/) {//bottom edge
			  n.neighbors.push_front(&m_grid[i + 1][j]);
		  }

	  }
      //Note: 
      // We consider 4-connection neighbors here. (N, W, E, S)
      // A node n has a neighobor node m iff both m and n are free (i.e. not occupied)
      // Thus, if a node is not free (i.e. occupied), it should not have any neighbors
      

    }//end j
  }//end i

  return true;
}



//finding a path using A*
bool MyGridPathPlanner::find_path( const Point2d& start, const Point2d& goal, std::list<Point2d>& path )
{
  //check if the start and goal are valid (i.e., inside the screen)
  if(start[0]<0 || start[1]>=getMyGame()->getScreenWidth()) return false;
  if(goal[0]<0 || goal[1]>=getMyGame()->getScreenWidth()) return false;

  float cell_w=getMyGame()->getScreenWidth()*1.0f/m_width;
  float cell_h=getMyGame()->getScreenHeight()*1.0f/m_height;

  //vector<Node *> open, close;
  Node * S=&m_grid[(int)(start[1]/cell_h)][(int)(start[0]/cell_w)];
  Node * G=&m_grid[(int)(goal[1]/cell_h)][(int)(goal[0]/cell_w)];

  if (!S->free) {
	  cerr << "! Error: Start point makes the agent collide with something" << endl;

	  path.clear();
	  path.push_front(goal);  //replace this
	  path.push_front(start); //replace this
	  return false;
  }
  if (!G->free) {
	  cerr << "! Error: Goal point makes the agent collide with something" << endl;

	  path.clear();
	  path.push_front(goal);  //replace this
	  path.push_front(start); //replace this
	  return false;
  }
  bool found = true;

  //dummy path planning, replace the following two lines with A*

  //reset grid data
  for (int i = 0;i < m_height;i++)
  {
	  for (int j = 0;j < m_width;j++)
	  {
		  Node & no = m_grid[i][j];
		  no.parent = NULL;
		  no.f = no.g = FLT_MAX;
		  no.visited = false;
	  }
  }

  path.clear();
  //path.push_front(goal);  //replace this
  //path.push_front(start); //replace this
  
  //
  //priority_queue<Point2d> open;
  //priority_queue<Point2d> closed;
  priority_queue<Node *, vector<Node *>, decltype(&comp)> openlist(comp);
  priority_queue<Node *, vector<Node *>, decltype(&comp)> closedlist(comp);
  priority_queue<Node *, vector<Node *>, decltype(&comp)> templist(comp);
  int j = start[0]/cell_w, i = start[1]/cell_h;//j is x, i is y
 // m_grid[i][j].f = sqrt(pow((i - goal[0]), 2) + pow((j - goal[1]), 2));
  m_grid[i][j].f = cost(start, goal);
  m_grid[i][j].g = 0;
  m_grid[i][j].parent = NULL;

  
  //open.push(Point2d(i, j));
  openlist.push(&m_grid[i][j]);
  while (!openlist.empty()) {
	  Node * n = openlist.top();
	  //i = openlist.top()
	  openlist.pop();
	  closedlist.push(n);
	  n->visited = true;
	  if ((abs(n->pos[0] - goal[0]) < cell_w) && (abs(n->pos[1] - goal[1]) < cell_h) ) {
		  //goal found
		  while (n != NULL) {//fill path
			  path.push_front(n->pos);
			  n = n->parent;
		  }
		  path.push_front(start);
		  return true;
		  break;
	  }
	  else {
		  double gNew, fNew;
		  for (Node * neighbor : n->neighbors) {
			  //screen space
			  int nx = neighbor->pos[0];// x of neighbor in screen space
			  int ny = neighbor->pos[1];
			  //grid space
			  int nj = nx * cell_w;
			  int ni = ny * cell_h;
			  //set parent
			  float ng = cost(n->pos, neighbor->pos);

			  //check if neighbor is in closedlist
			  
			  //if neighbor is visited, skip
			  if (neighbor->visited) {
				  continue;
			  }

			  if ((/*neighbor->parent == NULL ||*/ neighbor->g > ng) ) {
				  neighbor->parent = n;
				  //set f and g
				  neighbor->g = n->g + cost(n->pos, neighbor->pos);
				  neighbor->f = neighbor->g + cost(neighbor->pos, goal);
			  }
			  //check if neighbor is in openlist
			  bool isInOpen = false;
			  while (!isInOpen && !openlist.empty()) {
				  Node * check = openlist.top();
				  if (neighbor == check) {
					  isInOpen = true;
				  }
				  else {
					  templist.push(check);
					  openlist.pop();
				  }
			  }
			  //put openlist back together
			  while (!templist.empty()) {
				Node * check = templist.top();

				openlist.push(check);
				templist.pop();
			  }
			  //if neighbor not in openlist, add it to openlist
			  if (! isInOpen) {
				  openlist.push(neighbor);
			  }
		  }
	  }
  }
  path.push_front(start);

  //

  return false;
  return found;
}



//TODO: shorten and smooth the path (20 pts, 10 pts each)
//To smooth, use Quadratic Bezier curves
void MyPathPlanner::shorten_and_smooth(std::list<Point2d>& path)
{
  
  //We assume that the agent can travel along the path without colliding with
  //any static obstacles/objects
  //
  //
  //Note: "path" is both input and output
  //
  //Hints: 
  //  shorten: Pick a pair of points on the path
  //           make sure the line connecting the points are collision free
  //           replace all points in between with the line
  //           
  //  smooth: Pick 3 points on the path
  //          Compute the Quadratic Bezier curve from these 3 points
  //          Replace all points in between with the curve 
  //
  //  combined: Pick 3 points and smooth the path. 
  //            If failed, use 1st and 3rd point to shorten the path.

	//iterate through every 3 points
	std::list<Point2d>::iterator p2 = path.begin();
	std::list<Point2d>::iterator p0 = p2 ++;
	std::list<Point2d>::iterator p1 = p2++;
	int na = 0;
	for (p0 = path.begin(); p2 != path.end() && p1 != path.end(); na += 0)
	{
		//try to smooth path
		bool success = true;
		//cannot dereference iterator, cannot access members, I don't know how to smooth with these restrictions
		/*if (!collision_detection(Point2d((p0->v[0] + p2[0]) / 2, (p0[1] + p2[1]) / 2))) { //if no collision between p0 and p2
			for (float t = 1; t >= 0; t -= 0.1) {
				Point2d pb = Point2d((1 - t)*((1 - t) * (*p0)[0] + t * (*p1)[0]) + t * ((1 - t)*(*p1)[0] + t * (*p2)[0]), (1 - t)*((1 - t) * (*p0)[1] + t * (*p1)[1]) + t * ((1 - t)*(*p1)[1] + t * (*p2)[1]));
				//if (!collision_detection(pb)) {
				path.insert(p1, pb);
				//}

			}
			p0 = p1;
			path.remove(*p1);
			p1 = p2;
			p2++;

		//}*/
		//else {
			//move forward
			p0++;
			p1++;
			p2++;
		//}*/
	}
}

}//end namespace GMUCS425
